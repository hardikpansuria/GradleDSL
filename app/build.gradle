apply plugin: "com.android.application"

android {
    compileSdkVersion 26
    buildToolsVersion "26.0.2"

    defaultConfig {
        applicationId "com.willkernel.app.gradledsl"
        minSdkVersion 19
        targetSdkVersion 26
        versionCode 1
        versionName "1.0.0"
        multiDexEnabled true

        /**
         * The AndroidJUnitRunner class has support for JUnit 4 annotations.
         * To use it, you can add the @RunWith annotation from JUnit to your
         * test class, or you can add a setting to the defaultConfig block of
         * your Gradle build file
         * Using AndroidJUnitRunner by default
         */
        testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"

        // get the git hash in your Java code with BuildConfig.GitHash.
//        buildConfigField "String", "GitHash", "\"${getGitHash()}\""

        //Rename the output apk
//        applicationVariants.all { variant ->
//            variant.outputs.each { output ->
//                def formattedDate = new Date().format('yyyyMMddHHmmss')
//                def file = output.packageApplication.outputFile
//                def fileName = file.name.replace("app", "willkernel") + formattedDate
////                + rootProject.GitHash
//                output.packageApplication.outputFile = new File(file.parent, fileName)
//            }
//        }
    }

    signingConfigs {
        release {
            /**  Generating a release key , keytool -help 获取帮助
             keytool -genkey -v -keystore app.keystore/app.jks -alias gradle -keyalg RSA -keysize 2048 -validity 10000 (all on one line)
             正在为以下对象生成 2,048 位RSA密钥对和自签名证书 (SHA256withRSA) (有效期为 20,000 天)*/
            keyAlias project.keyAlias

            //通过命令行设置see config.gradle
            //或者通过环境变量获取这些密码 System.getenv("KEYPWD")
            //或者构建流程在您要从命令行调用此构建时提示您输入这些密码
            //System.console().readLine("\nKey password: ")
            keyPassword project.keyPassword

            storeFile file('../' + project.storeFile)

            //System.getenv("KSTOREPWD")
            //System.console().readLine("\nKeystore password: ")
            storePassword project.storePassword
        }

        debug {
            /**   shows how to list the default certificate
             c:\Users\willkernel\.android> keytool -list -keystore debug.keystore

             The keystore type is JKS, which stands for (naturally enough) Java KeyStore, used
             for public and private keys. Java supports another type called JCEKS (Java Cryptography
             Extensions KeyStore), which can be used for shared keys, but isn’t used for
             Android applications.
             The keystore has a self-signed certificate with an alias of androiddebugkey, which is
             used to sign debug APKs when they are deployed to connected devices or emulators.
             To reset the debug keystore, simply delete the file debug.keystore. It
             will be re-created next time you deploy an app.*/
        }
    }

//    http://google.github.io/android-gradle-dsl/current/com.android.build.gradle.internal.dsl.BuildType.html
    buildTypes {
        debug {

        }

//      sign release apk by running gradlew assembleRelease
        release {
            //Properties
            applicationIdSuffix '.release'
            //Application id suffix. It is appended to the "base" application
            // id when calculating the final application id for a variant.

//          Version name suffix. It is appended to the "base" version name
//          when calculating the final version name for a variant.
            versionNameSuffix '-release'

            minifyEnabled true  //Whether removal of unused java code is enabled.
            zipAlignEnabled true  //Whether zipalign is enabled for this build type.
            crunchPngs true     //Whether to crunch PNGs.
            multiDexEnabled     //Whether Multi-Dex is enabled for this variant.
//            multiDexKeepFile : Text file that specifies additional classes that will be compiled into the main dex file.
//            multiDexKeepProguard : Text file with additional ProGuard rules to be used to determine which classes are compiled into the main dex file.

            //Whether shrinking of unused resources is enabled. Default is false
            shrinkResources true

            //Whether this build type should generate a debuggable apk.
            debuggable false

            useProguard true
//            Specifies whether to always use ProGuard for code and resource shrinking

//            Optimization level to use by the renderscript compiler.
//            renderscriptOptimLevel

//            Whether the build type is configured to generate an apk with debuggable RenderScript code.
//            renderscriptDebuggable

            signingConfig signingConfigs.release

            //Methods
            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
        }

        /**
         * The 'initWith' property allows you to copy configurations from other build types,
         * so you don't have to configure one from the beginning. You can then configure
         * just the settings you want to change. The following line initializes
         * 'jnidebug' using the debug build type, and changes only the
         * applicationIdSuffix and versionNameSuffix settings.
         */

        jnidebug {

            // This copies the debuggable attribute and debug signing configurations.
            initWith debug

            applicationIdSuffix ".jnidebug"
            jniDebuggable true
        }

    }

    /**  Specifies the flavor dimensions you want to use. The order in which you
     list each dimension determines its priority, from highest to lowest,
     when Gradle merges variant sources and configurations. You must assign
     each product flavor you configure to one of the flavor dimensions.*/
    flavorDimensions "mode", "client", "api"
    /**One additional note is necessary here. The flavorDimensions tag in the Gradle build
     file listed attitude before client, which means values from the attitude dimension
     will have higher priority than the client dimension. Therefore, the hello_world
     string resource was removed from each of the attitude flavors. Switching the order of
     client and attitude would have worked just as well, of course*/

// The priority is: build type overrides Product Flavor,
// which overrides the main source set.
    productFlavors {
        free {
            applicationId "com.willkernel.app.gradledsl.free"
//            applicationIdSuffix '.free'
            versionNameSuffix '-free'
            dimension "mode"
        }

        paid {
            applicationId "com.willkernel.app.gradledsl.paid"
//            applicationIdSuffix '.paid'
            versionNameSuffix '-paid'
            dimension "mode"
        }

        pro {
            applicationId "com.willkernel.app.gradledsl.pro"
//            applicationIdSuffix '.pro'
            versionNameSuffix '-pro'
            dimension "mode"
        }

        /** Configurations in the "api" product flavors override those in "mode"
         flavors and the defaultConfig {} block. Gradle determines the priority
         between flavor dimensions based on the order in which they appear next
         to the flavorDimensions property above--the first dimension has a higher
         priority than the second, and so on.*/
        minApi24 {
            dimension "api"
            minSdkVersion '24'
            // To ensure the target device receives the version of the app with
            // the highest compatible API level, assign version codes in increasing
            // value with API level. To learn more about assigning version codes to
            // support app updates and uploading to Google Play, read Multiple APK Support
            versionCode 30000 + android.defaultConfig.versionCode
            versionNameSuffix "-minApi24"
        }

        minApi21 {
            dimension "api"
            minSdkVersion '21'
            // To ensure the target device receives the version of the app with
            // the highest compatible API level, assign version codes in increasing
            // value with API level. To learn more about assigning version codes to
            // support app updates and uploading to Google Play, read Multiple APK Support
            versionCode 20000 + android.defaultConfig.versionCode
            versionNameSuffix "-minApi21"
        }

        stark {
            dimension 'client'
        }

        wayne {
            dimension 'client'
        }
    }
    //过滤变体
    variantFilter { variant ->
        def names = variant.flavors*.name
        // To check for a certain build type, use variant.buildType.name == "<buildType>"
        if (names.contains("minApi24") || names.contains("Jnidebug")
                || names.contains("stark")) {
            // Gradle ignores any variants that satisfy the conditions above.
            setIgnore(true)
        }
    }

    /**https://developer.android.com/studio/build/build-variants.html
     * 当没有设置时sourceSets, free,paid,pro这三个dir作为 flavors,build三个不同的apk
     * 当设置sourceSets,三个dir作为源码,属于同一个项目的不同模块,这时会出现类,资源Duplicate
     * 所以在src中添加更有意义的目录为
     * 'main',  main sample code; look here for the interesting stuff.
     * 'common', components that are reused by multiple samples
     * 'template' boilerplate code that is generated by the sample template process
     */
    List<String> dirs = ['main', 'common', 'template']
    sourceSets {
        main {
            dirs.each { dir ->
                java.srcDirs "src/${dir}/java"
                res.srcDirs "src/${dir}/res"
//            manifest.srcFile 'src/${dir}/AndroidManifest.xml'
            }
        }

        /**Changing the root directory for tests*/
//        androidTest {
//            setRoot 'tests'
//            java.srcDirs 'tests/src'
//        }
    }

    /**
     * Extending the ADP Timeout Period Changing the ADB timeout period
     * This extends the timeout limit to 30 seconds.
     * Adjust this value if you are getting
     * ShellCommandUnresponsiveException failures.
     * */
    adbOptions {
        timeOutInMs = 30 * 1000
    }

    /**control the “dex” process that converts
     Java byte codes (i.e., .class files) to Dalvik executables (.dex files). The dexOp
     tions block contains the options
     The incremental option specifies whether to enable the incremental mode for the dx
     processor. As the documentation says, “this has many limitations and may not work.Use carefully.

     Use javaMaxHeapSize as an alternative way of specifying Xmx values during the dx
     run, in 1024m increments—so here it is set to 2 gigs.

     Enabling “jumbo mode” allows a larger number of strings in the dex files. If that’s an
     issue, you may want to spend more time on configuring ProGuard.

     The preDexLibraries will run the dx process on libraries ahead of time, just as it
     sounds. As the docs say, “this can improve incremental builds, but clean builds may
     be slower.”

     All of these settings can both help and hurt performance, so be sure to try them out
     before adopting them.
     */
    dexOptions {
//        incremental true deprecated
        javaMaxHeapSize '2g'
        jumboMode true
        preDexLibraries true
    }

    /**
     * You can set a project property from the command line using the -P flag, as
     * gradlew build -PnoLint | grep lint
     */
    lintOptions {
        abortOnError false
        ignoreWarnings true
//        if abortOnError false will not resolve your problem, you can try this.
//        checkReleaseBuilds false
    }
    compileOptions {
        sourceCompatibility JavaVersion.VERSION_1_7
        targetCompatibility JavaVersion.VERSION_1_7
    }

//    Profiling your build
//    You can run Gradle with the --profile command-line option to generate useful
//    information about the build.
//    gradlew --profile assembleDebug
//    The output report is in the build/reports/profile folder, with a filename of the form
//    “profile-YYYY-MM-dd-hh-mm-ss.html”, where the part after the word “profile”
//    refers to timestamp quantities year, month, day, hour, minute, and seconds.
//    larger projects this is a good way to find bottlenecks in your process
}

dependencies {
    //    implementation files('libs/a.jar', 'libs/b.jar')
    //    implementation fileTree(dir: 'libs', include:[ '*.jar'])
    //    implementation project(":androidlib")
    //    testRuntimeOnly
    //    runtimeOnly
    //    define your own


    implementation fileTree(include: ['*.jar'], dir: 'libs')
    implementation 'com.android.support:appcompat-v7:26.1.0'
    implementation 'com.android.support.constraint:constraint-layout:1.0.2'
    testImplementation "junit:junit:$rootProject.ext.JUNIT_VERSION"
    androidTestImplementation 'com.android.support.test:runner:1.0.1'
    androidTestImplementation 'com.android.support.test.espresso:espresso-core:3.0.1'
    implementation 'com.android.support:multidex:1.0.2'

    //    Adding the Google Maps dependency only
    //    implementation 'com.google.android.gms:play-services:11.6.2'
    implementation 'com.google.android.gms:play-services-maps:11.6.2'

    //    implementation 'org.codehaus.groovy:groovy-all:2.4.4@jar'
    //    androidTestImplementation('org.spockframework:spock-core:1.0-groovy-2.4') {
    //        exclude group: 'org.codehaus.groovy'
    //        exclude group: 'junit'
    //    }
}

/**A custom task to print available variants
 * The applicationVariants property is only available for the
 * com.android.application plug-in. A libraryVariants property
 * is available in Android libraries. A testVariants property
 * is available in both.
 */
task printVariantNames() {
    doLast {
        android.applicationVariants.all { variant ->
            println variant.name
        }
    }
}

/**
 * The buildDir property refers to the default build directory (app/build),
 * and the dollar sign is used to inject it into a Groovy string (with double quotes).
 * The documentation for the Copy task shows that the exclude block inside from supports an Ant-style
 * directory name, meaning that ** matches all descendent directories.
 *
 * The dependency on assembleDebug means all the debug APKs will be generated
 * before the copy task runs. You can use assemble instead
 * if you want the release APKs as well.
 * */
task copyApks(type: Copy, dependsOn: "assembleDebug") {
    from("$buildDir/outputs/apk/freeWayneMinApi21") {
        exclude '**/*unsigned.apk', '**/*unaligned.apk', '**/*.json'
        rename 'app', 'willkernel'
        includeEmptyDirs = false
    }
//    into "C:\\Users\\willkernel\\Desktop\\output"
    into "../apks"
}

/**Making copyApks a part of the build*/
build.dependsOn copyApks

/**
 * When Gradle runs, it assembles a directed acyclic graph, known as a task graph. You
 can get a reference to it inside your build file through the gradle object. Any manipulation
 of the graph needs to be done after it has been formed, so you want to use the
 whenReady property before applying any changes.

 * Disabling all tasks that start with the word lint
 * The result is that all tasks that have a name that starts with the letters lint have their
 enabled property set to false, so none of them will run.
 set property : gradlew build -PnoLint | grep lint
 Only disable the lint tasks if the noLint property is set
 */
gradle.taskGraph.whenReady { graph ->
    if (project.hasProperty('noLint')) {
        graph.allTasks.findAll { it.name ==~ /lint.*/ }*.enabled = false
    }
}

/**In this case, the dependsOn method shows that this is part of the configuration
 process rather than execution. Each variant name, like friendlyDebug, is capitalized
 (FriendlyDebug) and then the corresponding installation task (install
 FriendlyDebug) is added as a dependency to the installDebugFlavors task.
 The result is during the configuration process, installArrogantDebug, install
 FriendlyDebug, and installObsequiousDebug are all added as dependencies to
 installDebugFlavors. Therefore, executing installDebugFlavors at the command
 line requires all three flavor installs.
 run command gradlew instDebFl
 */
task installDebugFlavors() {
    android.applicationVariants.all { v ->
        if (v.name.endsWith('Debug')) {
            String name = v.name.capitalize()
            dependsOn "install$name"
        }
    }
}

// get hash of current commit
//def getGitHash() {
//    def stdout = new ByteArrayOutputStream()
//    exec {
//        commandLine 'git', 'rev-parse', '--short', 'HEAD'
//        standardOutput = stdout
//    }
//
//    return "-" + stdout.toString().trim()
//}